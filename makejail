#!/usr/bin/python3
# -*- coding: utf-8; tab-width: 4; -*-

# Authors:
#   Matthias "Maddes" Bücher <maddes+debian@maddes.net> - conversion to Python 3.5
#   Javier Fernandez-Sanguino Peña <jfs@debian.org> - author of Debian version
#   Alain Tésio <alain@onesite.org> - original author
# Contributors:
#   Florian Grandel <jerico.dev@gmail.com>
#   Matthias "Maddes" Bücher <maddes+debian@maddes.net>
# License: GPL
# OS: GNU/Linux
# Version: 0.0.5

# Required unusual external programs:
# strace (package strace)
# killall (package psmisc)
# stat (package stat)

# Configuration defaults
# Don't change this file, to define new defaults values create a file /etc/makejail/makejail.conf

class configClass:
	def __init__(self):
		self.chroot = None
		self.packages = []
		self.useDepends = 0
		self.blockDepends = []
		self.doNotCopy = [
			"/usr/share/doc",
			"/usr/share/info",
			"/usr/share/man",
			"/etc/fstab",
			"/etc/mtab",
			"/proc",
			]
		self.forceCopy = []
		self.cleanJailFirst = 0
		self.preserve = []
		self.testCommandsInsideJail = []
		self.processNames = []
		self.testCommandsOutsideJail = []
		self.maxExecutions = 100
		self.sleepAfterStartCommand = 2
		self.sleepAfterTest = 2
		self.sleepAfterKillall = 1
		self.sleepAfterStraceAttachPid = 0.2
		self.maxRemove = 500
		self.keepStraceOutputs = 0
		self.promptForInteractiveTests = 0
		self.promptForSomeMoreTests = 0
		self.users = []
		self.groups = []

		self.debianDpkgInfoFile = "/var/lib/dpkg/info/{package:s}.list"
		self.etcFile = "/etc/makejail/makejail.conf"
		self.pathToLdConfig = "/sbin/ldconfig"
		# For Ubuntu systems, to prevent copying a bash shell
		# we copy ldconfig.real instead
		if os.path.exists("/sbin/ldconfig.real"):
			self.pathToLdConfig = "/sbin/ldconfig.real"
		self.pathToLdSoConf = "/etc/ld.so.conf"
		self.pathToLdSoCache = "/etc/ld.so.cache"
		self.procPath = "/proc"
		self.userFiles = [
			"/etc/passwd",
			"/etc/shadow",
			"/etc/master.passwd",
			]
		self.groupFiles = [
			"/etc/group",
			"/etc/gshadow",
			]
		self.tempDir = "/tmp/makejail_logs"

		self.psCommand = "ps -e"
		self.psColumns = [1, 4]

		# -e file=trace doesn't catch socket connections
		self.straceCommand = "strace -e trace=file,connect -e signal=none -f -ff -o {file:s} {command:s} >/dev/null 2>&1"
		self.straceCommandPid = "strace -e trace=file,connect -e signal=none -f -ff -o {file:s} -p {pid:d} >/dev/null 2>&1"
		self.straceCommandStop = "killall -9 strace"
		self.straceCommandView = None
		self.stracePatterns = [
			'.*\("([^"]*)",.*\) .*= -[0-9]* ENO.*',
			'.*\("([^"]*)",.*\) .*= -[0-9]* EACCES.*',
			'chdir\("([^"]*)"\) .*= -[0-9]* ENO.*',
			'chdir\("([^"]*)"\) .*= -[0-9]* EACCESS.*',
			]
		self.straceCreatePatterns = [
			'.*\("([^"]*)",.*O_CREAT.*\) .* ENOENT .*',
			'bind\(.* path="([^"]*)".* ENOENT .*',
			]
		self.straceSocketPatterns = [
			'connect\(.* path="([^"]*)".* ENOENT .*',
			]


# Global variables
needLdCache = 0
warnings = []
procMounted = 0
compiledRegExps = {}
installedPackages = []
installedFiles = {}
indentLevel = 0
doNotKillPids = []
tmpOut = None
# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=680283
archs = []


import stat
import sys
import importlib.util # library 'imp' removed in 3.12
import importlib.machinery # library 'imp' removed in 3.12
import os
import shutil
import subprocess # library 'popen2' removed in 3.0
import tempfile
import re
import glob
import time
import select
import fcntl


# May be useful to parse correctly some program outputs
os.environ["LANG"] = "C"


def moveIndent(direction):
	global indentLevel

	indentLevel = indentLevel + direction


def debug(s, endLine=1):
	sys.stdout.write("   " * indentLevel + s + "\n" * endLine)


def abort(s):
	sys.stderr.write("\nERROR: {error:s}\n".format(error=s))
	sys.exit(1)


def compileRegExp(pattern):
	global compiledRegExps

	if pattern in compiledRegExps:
		compiled = compiledRegExps[pattern]
	else:
		compiled = re.compile(pattern)
		compiledRegExps[pattern] = compiled
	return compiled


def matchPattern(pattern, line, nextLine=None):
	# If pattern is an array of two strings, matches the first pattern
	# only if the next line matches the second pattern
	if pattern == None:
		return None
	elif isinstance(pattern, str):
		matchobject = compileRegExp(pattern).match(line)
		if matchobject:
			return matchobject.groups()[0]
	elif nextLine:
		(currentPattern, nextPattern) = pattern
		matchobject = compileRegExp(currentPattern).match(line)
		if matchobject and compileRegExp(nextPattern).match(nextLine):
			return matchobject.groups()[0]


def matchPatterns(patterns, line, nextLine=None):
	if patterns == None:
		return None
	for pattern in patterns:
		match = matchPattern(pattern, line, nextLine)
		if match:
			return match


def cleanDir(queue, dir):
	# test inode for hardlink
	debug("Entering directory {dir:s}".format(dir=dir))
	moveIndent(1)
	keepUpperDir = 0
	files = os.listdir(dir)
	for file in files:
		file = "{dir:s}/{file:s}".format(dir=dir, file=file)
		doNotTouchThat = 0
		for path in config.preserve:
			if file.startswith("{chroot:s}{file:s}".format(chroot=config.chroot, file=path)):
				doNotTouchThat = 1
				break
		if doNotTouchThat:
			debug("Preserving {file:s}".format(file=file))
			keepUpperDir = 1
			continue
		keepThisDir = 0
		if os.path.isdir(file) and not(os.path.islink(file)) and file != config.chroot:
			if file == "{chroot:s}{file:s}".format(chroot=config.chroot, file=config.procPath):
				debug("{file:s} : mount point, do not try removing files deeper".format(file=config.procPath))
			else:
				if cleanDir(queue, file):
					keepThisDir = 1
					keepUpperDir = 1
		if keepThisDir:
			if file != "{chroot:s}{file:s}".format(chroot=config.chroot, file=config.procPath):
				debug("   Not queueing for remove {file:s}, some paths to preserve below".format(file=file))
		else:
			debug("   Queuing for remove {file:s}".format(file=file))
			queue.append(file)
	moveIndent(-1)
	return keepUpperDir


def cleanJail():
	queue = []
	debug("Cleaning jail")
	moveIndent(1)
	cleanDir(queue, config.chroot)
	moveIndent(-1)
	if len(queue) > config.maxRemove:
		abort("Found {count:d} files to remove, the maximum is {max:d}".format(count=len(queue), max=config.maxRemove))
	debug("Removing {count:d} files in queue".format(count=len(queue)))
	for file in queue:
		debug("   Removing {file:s}".format(file=file))
		try:
			if os.path.isdir(file) and not(os.path.islink(file)):
				os.rmdir(file)
			else:
				os.unlink(file)
		except OSError:
			if file == "{chroot:s}{file:s}".format(chroot=config.chroot, file=config.procPath):
				debug("      Cannot remove {file:s}, it's probably mounted".format(file=config.procPath))
			else:
				abort("Cannot remove the path {file:s}".format(file=file))


def readFileLines(fileName):
	try:
		f = open(fileName, "r")
	except IOError:
		abort("Cannot read file '{file:s}'".format(file=fileName))
	lines = f.readlines()
	f.close()
	return list(map(str.strip, lines))


def dpkgInfoFiles(packagename):
	# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=680283
	for arch in archs:
		package = "{package:s}{arch:s}".format(package=packagename, arch=arch)
		if os.path.exists(config.debianDpkgInfoFile.format(package=package)):
			break
	return readFileLines(config.debianDpkgInfoFile.format(package=package))


def copyStatAndOwner(source, target):
	# Copy user/group info
	statInfos = os.stat(source)
	os.chown(target, statInfos[stat.ST_UID], statInfos[stat.ST_GID])

	# Keep all attributes
	shutil.copystat(source, target)


def unmountProc():
	debug("Unmounting {path:s}".format(path=config.procPath))
	moveIndent(1)
	returnCode = os.system("umount -t proc {chroot:s}{file:s}".format(chroot=config.chroot, file=config.procPath))
	if returnCode == 0:
		debug("{file:s} unmounted successfully".format(file=config.procPath))
	else:
		abort("Unable to unmount {file:s}".format(file=config.procPath))
	moveIndent(-1)


def mountProc():
	debug("Mounting {file:s}".format(file=config.procPath))
	moveIndent(1)
	returnCode = os.system("mount -t proc proc {chroot:s}{file:s}".format(chroot=config.chroot, file=config.procPath))
	if returnCode == 0:
		debug("{file:s} mounted successfully".format(file=config.procPath))
		warnings.append(("/proc", None))
	else:
		abort("Unable to mount {file:s}".format(file=config.procPath))
	moveIndent(-1)


def addPasswdFile(file, what):
	moveIndent(1)
	if what == "users":
		entries = config.users
	elif what == "groups":
		entries = config.groups
	else:
		raise ValueError
	dest = "{chroot:s}{file:s}".format(chroot=config.chroot, file=file)
	debug("Copying with filtering on {what:s} : {file:s} -> {dest:s}".format(what=what, file=file, dest=dest))
	if "*" in entries:
		debug('Entry "*" in {what:s}, the file is simply copied'.format(what=what))
		shutil.copy(file, dest)
	else:
		f = open(file, "r")
		lines = f.readlines()
		f.close()
		d = open(dest, "w")
		matches = []
		for line in lines:
			if not(":" in line):
				continue
			entry = line.split(":")[0]
			if entry in entries:
				d.write(line)
				matches.append(entry)
		d.close()
		if len(matches) > 1:
			entryString = "entries"
		else:
			entryString = "entry"
		debug("{count:d} {entry:s} copied : {matches:s}".format(count=len(matches), entry=entryString, matches=",".join(matches)))
	moveIndent(-1)


def fileIsNewer(fileName1, fileName2):
	return os.stat(fileName1)[stat.ST_MTIME] > os.stat(fileName2)[stat.ST_MTIME]


def addFileToJail(fileName):
	global needLdCache, procMounted

	if not(fileName):
		return []
	missingFiles = []
	if fileName in installedFiles:
		return []
	debug("Checking path '{path:s}'".format(path=fileName))
	if fileName == config.pathToLdSoCache:
		installedFiles[fileName] = -1
		debug("   Shared libs cache file {file:s} marked as needed, it will be generated at the end".format(file=config.pathToLdSoCache))
		needLdCache = 1
		return []
	if config.doNotCopy:
		ignored = 0
		for ignorePath in config.doNotCopy:
			if fileName.startswith(ignorePath):
				ignored = 1
				break
		if ignored:
			debug("   Ignoring because of doNotCopy directive: {file:s}".format(file=fileName))
			installedFiles[fileName] = 0
			return []
	try:
		stats = os.stat(fileName)
	except OSError:
		debug("   The path '{file:s}' doesn't exist".format(file=fileName))
		return []
	statMode = stats.st_mode
	installedFiles[fileName] = 1
	if fileName[0] != "/":
		abort("The path '{path:s}' is not absolute".format(path=fileName))
	elif fileName == "/.":
		return []
	if fileName.startswith(config.procPath):
		if procMounted:
			debug("   {file:s} has just been mounted".format(file=config.procPath))
		else:
			os.mkdir("{chroot:s}{file:s}".format(chroot=config.chroot, file=config.procPath))
			os.chmod("{chroot:s}{file:s}".format(chroot=config.chroot, file=config.procPath), 0o0555)
			mountProc()
			procMounted = 1
		return []
	targetDirs = fileName[1:].split("/")[:-1]
	checkDir = ""
	for targetDir in targetDirs:
		checkDir = checkDir + "/{dir:s}".format(dir=targetDir)
		fileInChroot = "{chroot:s}{file:s}".format(chroot=config.chroot, file=checkDir)
		if not(os.path.isdir(fileInChroot)):
			debug("   Dir '{dir:s}' missing".format(dir=fileInChroot))
			moveIndent(1)
			addFileToJail(checkDir)
			moveIndent(-1)
	# The directory part of fileName may be a symlink to an
	# absolute pathname.  For example, fileName is
	# "lib64/ld-linux.so.2" where "lib64" is a symlink to "/lib".
	# In that case it should be resolved before constructing
	# fileInChroot.  See http://bugs.debian.org/570695.
	fileDir, baseName = os.path.split(fileName)
	fileInChroot = os.path.join(config.chroot, os.path.realpath(fileDir)[1:], baseName)
	if os.path.exists(fileInChroot):
		if fileIsNewer(fileName, fileInChroot):
			debug("   File {file:s} is newer than the file {chfile:s}, overwriting".format(file=fileName, chfile=fileInChroot))
		else:
			debug("   File {chfile:s} already exists".format(chfile=fileInChroot))
			return []
	elif os.path.islink(fileName):
		linkTarget = os.readlink(fileName)
		debug("   '{file:s}' is a symlink to '{target:s}'".format(file=fileName, target=linkTarget))
		moveIndent(1)
		fileDir = os.path.split(fileName)[0]
		if linkTarget[-1] == "/":
			linkTarget = linkTarget[:-1]
		if linkTarget[0] == "/":
			absoluteLinkTarget = linkTarget
		else:
			absoluteLinkTarget = "{dir:s}/{target:s}".format(dir=fileDir, target=linkTarget)
		newFiles = addFileToJail(absoluteLinkTarget)
		missingFiles = missingFiles + newFiles
		# newWorkingDir may be a symlink to an absolute
		# pathname.  See the above comment.
		newWorkingDir = "{chroot:s}/{file:s}".format(chroot=config.chroot, file=os.path.realpath(fileDir)[1:])
		os.chdir(newWorkingDir)
		debug("   Creating '{file:s}' as a symlink to '{target:s}' (pwd={dir:s})".format(file=fileName[1:], target=linkTarget, dir=newWorkingDir))
		# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=825381
		if os.path.lexists(os.path.split(fileName)[1]):
			os.remove(os.path.split(fileName)[1])
		os.symlink(linkTarget, os.path.split(fileName)[1])
		os.chdir("/")
		missingFiles.append(fileName)
		moveIndent(-1)
	elif stat.S_ISSOCK(statMode):
		debug("Failed to connect to socket {file:s}, file exists".format(file=fileName))
		installedFiles[fileName] = -1
		warnings.append(("socket", (fileName, "exists")))
		return [fileName]
	elif os.path.isdir(fileName):
		if os.path.isdir(fileInChroot):
			debug("   Dir {dir:s} already exists".format(dir=fileInChroot))
			return []
		debug("   Making dir {dir:s}".format(dir=fileInChroot))
		os.mkdir(fileInChroot)
		missingFiles.append(fileName)
	elif stat.S_ISCHR(statMode) or stat.S_ISBLK(statMode):
		if stat.S_ISCHR(statMode):
			label = "character"
			deviceType = "c"
		else:
			label = "block"
			deviceType = "b"
		device = stats.st_rdev
		major = os.major(device)
		minor = os.minor(device)
		debug("   Creating {label:s} device {file:s} (major={major:d}, minor={minor:d})".format(label=label, file=fileName, major=major, minor=minor))
		os.system("mknod {file:s} {type:s} {major:d} {minor:d}".format(file=fileInChroot, type=deviceType, major=major, minor=minor))
		missingFiles.append(fileName)
	elif stat.S_ISBLK(statMode):
		debug("   Creating block device : {file:s} -> {chfile:s}".format(file=fileName, chfile=fileInChroot))
		os.system("cp -a {file:s} {chfile:s}".format(file=fileName, chfile=fileInChroot))
		missingFiles.append(fileName)
	elif fileName in config.userFiles:
		missingFiles.append(fileName)
		addPasswdFile(fileName, "users")
	elif fileName in config.groupFiles:
		missingFiles.append(fileName)
		addPasswdFile(fileName, "groups")
	else:
		debug("   Copying {file:s} -> {chfile:s}".format(file=fileName, chfile=fileInChroot))
		# Copy the file
		shutil.copy(fileName, fileInChroot)
		shutil.copystat(fileName, fileInChroot)
		missingFiles.append(fileName)

	copyStatAndOwner(fileName, fileInChroot)

	if os.path.isfile(fileName):
		checkRequirements(fileName)
	return missingFiles


def fileReadlines(fileName):
	f = open(fileName, "r")
	lines = f.readlines()
	f.close()
	return lines


def makeNonBlocking(fd):
	fl = fcntl.fcntl(fd, fcntl.F_GETFL)
	fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NDELAY)


def execute(command):
	debug("  Executing : {command:s}".format(command=command))
	child = subprocess.Popen(command, stdin=None, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True, shell=True, universal_newlines=True)
	files = (child.stdout, child.stderr)
	fds = [files[0].fileno(), files[1].fileno()]
	for fd in fds:
		makeNonBlocking(fd)
	datas = [[], []]
	feedbackQueues = ["", ""]
	finished = [False, False]
	while True:
		ready = select.select(fds, [], [])
		for i in (0, 1):
			if fds[i] in ready[0]:
				chunk = files[i].read()
				if chunk == "":
					finished[i] = True
				feedbackQueues[i] = feedbackQueues[i] + chunk
		for i in (0, 1):
			while "\n" in feedbackQueues[i]:
				pos = feedbackQueues[i].find("\n")
				line = feedbackQueues[i][:pos+1]
				datas[i].append(line[:-1])
				feedbackQueues[i] = feedbackQueues[i][pos+1:]
		if finished == [True, True]:
			break
		select.select([], [], [], .05)
	errCode = child.wait()
	if errCode:
		debug("  WARNING: exit code {code:d}".format(code=errCode))
	return datas[0]


def commandPids(processNames):
	pids = []
	for psLine in execute(config.psCommand)[1:]:
		processCommandLine = psLine.split()[config.psColumns[1]-1]
		name = processCommandLine.split()[0].split("/")[-1]
		if name in processNames:
			pid = int(psLine.split()[config.psColumns[0]-1])
			if not(pid in doNotKillPids):
				pids.append(int(pid))
	return pids


def fileType(file):
	return execute("file {file:s}".format(file=file))[0].split(":")[1].strip()


def checkRequirements(file):
	moveIndent(1)
	ft = fileType(file)
	if ft.find("script") != -1:
		f = open(file, "r")
		head = f.readline()
		f.close()
		if head[:2] == "#!":
			script = head[2:].split()[0]
			debug("{file:s} is a script run with the interpreter {script:s}".format(file=file, script=script))
			addFileToJail(script)
	else:
		sharedStrings = ("shared object", "dynamically linked")
		shared = None
		for sharedString in sharedStrings:
			if ft.find(sharedString) != -1:
				shared = sharedString
				break
		if shared:
			moveIndent(1)
			debug("{shared:s}, checking the required libraries with ldd".format(shared=shared))
			ldd_lines = list(map(str.strip, execute("ldd {file:s}".format(file=file))))
			ignoreStrings = [
				"not a dynamic executable",
				"statically linked",
				]
			for ignoreString in ignoreStrings:
				if ldd_lines[0] == ignoreString:
					debug(ignoreString)
					moveIndent(-2)
					return
			for line in ldd_lines:
				if not(line):
					continue
				# Not all ldd lines include => they might
				# reference the absolute path of the library
				if line.find("=>") == -1 and line.find("/") == -1:
					continue
				if line.find("=>") != -1:
					lib = line.split("=>")[1].split("(")[0].strip()
				else:
					lib = line.split("(")[0].strip()
				addFileToJail(lib)
			moveIndent(-1)
	moveIndent(-1)


def addPackageToJail(package):
	global installedPackages

	if (package in installedPackages):
		return
	installedPackages.append(package)

	if (package in config.blockDepends):
		debug("The package {package:s} is in Depends but won't be installed".format(package=package))
		return

	debug("Installing the package {package:s}".format(package=package))
	moveIndent(1)

	debug("Copying the files from the dpkg information")
	moveIndent(1)

	files = dpkgInfoFiles(package)
	for file in files:
		addFileToJail(file)

	moveIndent(-1)

	if config.useDepends:
		debug("Checking Depends")
		moveIndent(1)
		depends = debianGetDepends(package)
		for depend in depends:
			addPackageToJail(depend)
		moveIndent(-1)

	moveIndent(-1)


def addMissingFilesFromStraceLines(lines):
	missingFiles = []
	for n in range(len(lines)):
		line = lines[n]
		if n == len(lines) - 1:
			nextLine = None
		else:
			nextLine = lines[n+1]
		line = line.strip()

		missingFile = matchPatterns(config.stracePatterns, line, nextLine)
		if missingFile and not (missingFile in missingFiles):
			if missingFile == config.chroot:
				continue
			if missingFile.split("/")[-1] == "chroot":
				continue
			try:
				statInfos = os.stat(missingFile)
				fileExists = 1
			except OSError:
				fileExists = 0
			if fileExists:
				moveIndent(1)
				if addFileToJail(missingFile):
					missingFiles.append(missingFile)
				moveIndent(-1)
				continue

		missingFile = matchPatterns(config.straceCreatePatterns, line, nextLine)
		if missingFile and not (missingFile in missingFiles):
			debug("Failed attempt at creating the file {file:s}".format(file=missingFile))
			missingFile = removeTrailingSlashes(missingFile)
			dir = "/".join(missingFile.split("/")[:-1])
			if os.path.isdir(dir) and not(os.path.isdir(config.chroot + dir)):
				moveIndent(1)
				if addFileToJail(dir):
					missingFiles.append(dir)
				moveIndent(-1)
				continue

		missingFile = matchPatterns(config.straceSocketPatterns, line, nextLine)
		if missingFile and not(missingFile in installedFiles):
			try:
				statMode = os.stat(missingFile)[stat.ST_MODE]
			except:
				exists = "doesn't exist"
			else:
				if stat.S_ISSOCK(statMode):
					exists = "exists"
				else:
					exists = "exists but is not a socket ??"
			debug("Failed to connect to socket {file:s}, file {exists:s}".format(file=missingFile, exists=exists))
			installedFiles[missingFile] = -1
			warnings.append(("socket", (missingFile, exists)))

	return missingFiles


def removeTrailingSlashes(s):
	while s[-1] == "/":
		s = s[:-1]
	return s


def sleep(delay):
	if delay:
		if delay >= 2.0:
			s = "s"
		else:
			s = ""
		debug("Sleeping for {delay:.2f} second{plural:s}".format(delay=delay, plural=s))
		time.sleep(delay)


def addMissingFilesFromProcess(items, testCommandsOutsideJail=[]):
	straceTempFileName = tempfile.mktemp("trace")

	if not(isinstance(items, (list, tuple))):
		items = [items]

	for item in items:
		if isinstance(item, int):
			command = config.straceCommandPid.format(file=straceTempFileName, pid=item)
			s = "Tracing process {pid:d}".format(pid=item)
		elif isinstance(item, str):
			command = config.straceCommand.format(file=straceTempFileName, command=item)
			s = "Tracing command {command:s}".format(command=item)
		else:
			raise ValueError
		debug(s)
		os.system("{command:s} &".format(command=command))
		if isinstance(item, str):
			sleep(config.sleepAfterStartCommand)
		else:
			sleep(config.sleepAfterStraceAttachPid)

	if testCommandsOutsideJail:
		if not(isinstance(testCommandsOutsideJail, (list, tuple))):
			testCommandsOutsideJail = [testCommandsOutsideJail]
		for testCommand in testCommandsOutsideJail:
			if testCommand == "interactive":
				input("Interactive tests: press Enter when complete")
			else:
				debug("Executing test command '{command:s}' ...".format(command=testCommand))
				returnCode = os.system("{command:s} >/dev/null 2>/dev/null".format(command=testCommand))
				debug("   return code is {code:d}".format(code=returnCode))
				sleep(config.sleepAfterTest)

	debug("Stopping tracing ... ", endLine=0)
	lines = list(map(str.strip, execute(config.straceCommandStop)))
	out = []
	for line in lines:
		if line:
			out.append(line)
	debug(" ".join(out))

	# Join the generated pid-specific trace files (strace -ff) into one single trace file
	# If there are no such files the following lines should do nothing.
	debug("Joining pid-specific trace files (if any)...")
	command = "cat {file:s}.* >>{file:s} 2>/dev/null".format(file=straceTempFileName)
	os.system(command)
	os.system("rm -f {file:s}.* >/dev/null 2>/dev/null".format(file=straceTempFileName))

	if config.straceCommandView:
		command = config.straceCommandView.format(file=straceTempFileName)
		lines = execute(command)
	else:
		straceTempFile = open(straceTempFileName, "r")
		lines = straceTempFile.readlines()
		straceTempFile.close()

	if config.keepStraceOutputs:
		whatWillHappenToThisPoorTraceFile = " (available in {file:s})".format(file=straceTempFileName)
	else:
		whatWillHappenToThisPoorTraceFile = ""
		os.unlink(straceTempFileName)

	debug("Looking for missing files in the trace file{comment:s}".format(comment=whatWillHappenToThisPoorTraceFile))
	missingFiles = addMissingFilesFromStraceLines(lines)

	return missingFiles


def killall(processNames):
	if isinstance(processNames, str):
		processNames = [processNames]
	if len(processNames) == 1:
		s = "named '{process:s}'".format(process=processNames[0])
	else:
		s = "matching {processes:s}".format(processes=str(processNames))
	if processNames:
		debug("Killing processes {pattern:s} ... : ".format(pattern=s), endLine=0)
		pids = commandPids(processNames)
		if len(pids):
			debug(",".join(list(map(str, pids))))
			for pid in pids:
				out = execute("kill -9 {pid:d} 2>&1".format(pid=pid))
			sleep(config.sleepAfterKillall)
		else:
			debug("no process found")


def debianIsPackageInstalled(package):
	dpkgOut = execute("dpkg -l {package:s}".format(package=package))
	if not(dpkgOut):
		return 0
	lastLine = dpkgOut[-1]
	return (lastLine[0] == "i")


def debianGetDepends(package):
	depends = []
	for line in execute("dpkg -p {package:s}".format(package=package)):
		if line.startswith("Depends: "):
			packs = line[8:].replace("|", ",").split(",")
			for pack in packs:
				pack = pack.strip().split(" ")[0]
				if debianIsPackageInstalled(pack):
					depends.append(pack)
	return depends


def tryExecute(commands):
	if isinstance(commands, str):
		commands = [commands]
	for command in commands:
		debug("Executing command '{command:s}' (pwd={dir:s})".format(command=command, dir=config.tempDir), endLine=0)
		os.chdir(config.tempDir)
		returnCode = os.system("{command:s} >/dev/null 2>/dev/null &".format(command=command))
		debug("   return code is {code:d}".format(code=returnCode))


def checkConfig():
	if os.geteuid() != 0:
		abort("Effective user id is not 0, this command must be run as root")
	if not(config.chroot):
		abort("You didn't define the variable chroot")
	config.chroot = removeTrailingSlashes(config.chroot)
	if config.chroot[0] != "/":
		abort("The variable chroot must be an absolute path")
	if not(config.testCommandsInsideJail) and ("interactive" in config.testCommandsOutsideJail):
		abort("Cannot have 'interactive' in testCommandsOutsideJail if testCommandsInsideJail is not defined")


def runTests(tests, chrootCommands=None):
	finished = 0
	i = 1
	moveIndent(1)
	while not(finished):
		debug("Execution #{count:d}".format(count=i))
		moveIndent(1)
		if chrootCommands:
			sleep(config.sleepAfterStartCommand)
			pids = commandPids(config.processNames)
			if pids:
				missingFiles = addMissingFilesFromProcess(pids, tests)
			else:
				moveIndent(-1)
				return 0
		else:
			missingFiles = addMissingFilesFromProcess(tests)
		if not(missingFiles):
			debug("No missing file found")
			finished = 1
		elif i > config.maxExecutions:
			debug("Still missing files after {count:d} tries".format(count=config.maxExecutions))
			finished = 1
		i = i + 1
		if chrootCommands:
			killall(config.processNames)
			tryExecute(chrootCommands)
		moveIndent(-1)
	killall(config.processNames)
	moveIndent(-1)
	return 1


def displayWarnings():
	for warning in warnings:
		(warningType, warningDetail) = warning
		if warningType == "/proc":
			s = [
				"You'll need the filesystem procfs mounted as {chroot:s}{file:s}".format(chroot=config.chroot, file=config.procPath),
				"It's mounted now, you can mount it again for example before starting the daemon with :",
				"mount -t proc proc {chroot:s}{file:s}".format(chroot=config.chroot, file=config.procPath),
				]
		elif warningType == "socket":
			(socketFile, exists) = warningDetail
			if socketFile == "/dev/log":
				s = [
					"Attempt to access /dev/log, a socket used by syslogd. Some suggestions:",
					"- if your version of syslogd supports it you can tell it to listen to the",
					"  additional socket {chroot:s}/dev/log, and put it in the configuration directive 'preserve'".format(chroot=config.chroot),
					"  maybe start syslog with the option -a {chroot:s}/dev/log".format(chroot=config.chroot),
					"- use a syslog proxy like holelogd",
					"- configure the daemon to log into files instead through syslog",
					]
			else:
				s = [
					"Attempt to access the socket file {file:s}, which {exists:s} outside the jail".format(file=socketFile, exists=exists),
					"if needed it must be created inside the jail as {chroot:s}{file:s}""".format(chroot=config.chroot, file=socketFile),
					]
				s = s + [
					"If you create the socket, put it in the configuration option 'preserve'",
					"so it won't be deleted when you launch this script again",
					]
				if exists != "exists":
					s = s + [
						"As this socket doesn't exist outside the jail, you can probably ignore this warning safely.",
						]
		else:
			abort("No method to display the warning '{type:s}'".format(type=warningType))
		sys.stdout.write("\nWARNING:\n{lines:s}\n".format(lines="\n".join(["   {line:s}".format(line=l) for l in s])))


def initRunningPids():
	debug("Initializing list of running processes")
	for psLine in execute(config.psCommand)[1:]:
		pid = int(psLine.split()[config.psColumns[0]-1])
		doNotKillPids.append(pid)


def makeChroot():
	global tmpOut

	debug("Chroot directory is {chroot:s}".format(chroot=config.chroot))
	if not(os.path.isdir(config.chroot)):
		sys.stderr.write("ERROR: The chroot location defined '{chroot:s}' does not exist. Please create it and run makejail again.\n".format(chroot=config.chroot))
		sys.exit(1)

	# In the strace output, the command attempt to access
	# the directory where this script was started outside
	# the jail
	os.chdir("/")

	# See what processes are running so they don't get killed later
	initRunningPids()

	# Create temp strace dir
	if not(os.path.isdir(config.tempDir)):
		debug("Creating temp dir {dir:s}".format(dir=config.tempDir))
		os.mkdir(config.tempDir)
	tempfile.tempdir = config.tempDir

	tmpOut = tempfile.mktemp("out")

	killall(config.processNames)
	if config.cleanJailFirst:
		# We have to umount /proc before we proceed
		if os.path.isdir(config.chroot + config.procPath):
			unmountProc()
		cleanJail()

	# === Add packages
	for package in config.packages:
		addPackageToJail(package)

	# === Copy specific paths
	for globExpression in config.forceCopy:
		debug("Adding files matching '{pattern:s}'".format(pattern=globExpression))
		moveIndent(1)
		for file in glob.glob(globExpression):
			addFileToJail(file)
		moveIndent(-1)

	chrootCommands = []
	if config.testCommandsInsideJail:
		for command in config.testCommandsInsideJail:
			chrootCommands.append("chroot {chroot:s} {command:s}".format(chroot=config.chroot, command=command))

	# === Execute main command until there is no missing file
	if chrootCommands:
		finished = 0
		i = 1
		debug("Running strace on commands from inside jail")
		moveIndent(1)
		killall(config.processNames)
		while not(finished):
			debug("Execution #{count:d}".format(count=i))
			moveIndent(1)
			missingFiles = addMissingFilesFromProcess(chrootCommands)
			i = i + 1
			if not(missingFiles):
				debug("No missing file found")
				finished = 1
			if i > config.maxExecutions:
				debug("Still missing files after {count:d} tries".format(count=config.maxExecutions))
				finished = 1
			killall(config.processNames)
			moveIndent(-1)
		moveIndent(-1)

	# === Try it
	if chrootCommands:
		tryExecute(chrootCommands)

	# === Make tests
	continueTests = 1
	while continueTests:
		if config.testCommandsOutsideJail:
			debug("Running tests from outside the jail")
			if not(runTests(config.testCommandsOutsideJail, chrootCommands)):
				debug("No running process found, cannot run tests")
		if config.promptForInteractiveTests:
			debug("Running interactive tests from outside the jail")
			if chrootCommands:
				tryExecute(chrootCommands)
			if not(runTests(["interactive"], chrootCommands)):
				debug("No running process found, cannot run tests")
		continueTests = 0
		if config.promptForSomeMoreTests:
			prompt="Paused to give you a chance to fix some problems, do you want to run tests again (y/n) ? "
			while prompt:
				yesNo = input(prompt).lower()
				if yesNo == "y":
					continueTests = 1
					prompt = None
				elif yesNo == "n":
					continueTests = 0
					prompt = None
				else:
					prompt = "Please reply with 'y' or 'n': "
		if chrootCommands:
			tryExecute(chrootCommands)

	sleep(config.sleepAfterStartCommand)
	killall(config.processNames)

	# /etc/ld.so.cache
	if needLdCache:
		debug("Generating {path:s}".format(path=config.pathToLdSoCache))
		moveIndent(1)
		# /etc/ld.so.conf may contains path which are invalid in chroot, ldconfig ignores them
		addFileToJail(config.pathToLdSoConf)
		newLdConfig = "{chroot:s}{path:s}".format(chroot=config.chroot, path=config.pathToLdConfig)
		ldconfigAlreadyHere = os.path.isfile(newLdConfig)
		newFiles = addFileToJail(config.pathToLdConfig)
		tryExecute("chroot {chroot:s} {path:s}".format(chroot=config.chroot, path=config.pathToLdConfig))
		debug("Removing ldconfig from jail")
		moveIndent(1)
		newFiles.reverse()
		for file in newFiles:
			file = "{chroot:s}{file:s}".format(chroot=config.chroot, file=file)
			if os.path.islink(file) or os.path.isfile(file):
				debug("Removing file {file:s}".format(file=file))
				os.unlink(file)
			elif os.path.isdir(file):
				debug("Removing dir {dir:s}".format(dir=file))
				os.rmdir(file)
			else:
				raise ValueError
		moveIndent(-2)

	displayWarnings()


def loadConfig(file):
	debug("Loading configuration file {file:s}".format(file=file))

	moveIndent(1)

	try:
		assert os.path.isfile(file)
	except:
		abort("Cannot open configuration file '{file:s}'".format(file=file))

	if ("/" in file):
		dir = "/".join(file.split("/")[:-1])
		if dir[0] != "/":
			dir = "{path:s}/{dir:s}".format(path=os.getcwd(), dir=dir)
		sys.path.insert(0, dir)

	try:
		importlib.machinery.SOURCE_SUFFIXES.append('') # empty string to allow any file
		spec = importlib.util.spec_from_file_location("newConfig{file:s}".format(file=file), file)
		newConfig = importlib.util.module_from_spec(spec)
		spec.loader.exec_module(newConfig)
		importlib.machinery.SOURCE_SUFFIXES.pop()
	except:
		sys.stderr.write("ERROR: Cannot load configuration file '{file:s}' as a python module\n".format(file=file))
		sys.stderr.write("ERROR: Executing it with python which should display a syntax error:\n")
		os.system("python3 {file:s}".format(file=file))
		sys.exit(1)

	# Remove byte-compile file
	bcFile = "{file:s}c".format(file=file)
	if os.path.isfile(bcFile):
		os.unlink(bcFile)

	for key, value in newConfig.__dict__.items():
		if key[:2] == "__":
			continue
		if not(key in config.__dict__):
			abort("Invalid configuration key '{key:s}'".format(key=key))
		if isinstance(value, str):
			s = "'{value:s}'".format(value=value)
		else:
			s = "{value}".format(value=value)
		debug("Defining {key:s} = {value}".format(key=key, value=s))
		config.__dict__[key] = value

	moveIndent(-1)


if __name__ == "__main__":
	config = configClass()

	try:
		configFile = sys.argv[1]
	except IndexError:
		abort("Usage: {command:s} package\n\tpackage is the name of an installed package\n\t(a configuration file must exist in {file:s})".format(command=sys.argv[0], file=config.etcFile))

	# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=680283
	dpkg_stdout = os.popen("dpkg --print-architecture")
	dpkg_arch = dpkg_stdout.readline().rsplit()[0]
	if dpkg_arch != '':
		archs.append(':' + dpkg_arch)
	archs.append('') # fallback

	if os.path.isfile(config.etcFile):
		loadConfig(config.etcFile)

	loadConfig(configFile)

	checkConfig()
	makeChroot()

	sys.exit(0)
